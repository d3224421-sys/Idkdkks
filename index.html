<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Global Chat ‚Äî Hack7rBGG / Xymatekidd</title>
<meta name="description" content="Mobile global chat with profiles (avatars via file upload saved to Realtime DB)" />
<style>
  :root{
    --bg:#0d0f12; --panel:#121417; --accent:#1dd1a1; --muted:#9aa3ab;
    --bubble:#1b1d20; --bubble-you:#06394a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,var(--bg),#071017);color:#fff}
  /* Loading screen */
  #loadingScreen {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, var(--bg), #071017);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100;
    transition: opacity 0.3s ease;
  }
  
  #loadingScreen.hidden {
    opacity: 0;
    pointer-events: none;
  }
  
  .loading-spinner {
    width: 50px;
    height: 50px;
    border: 3px solid rgba(29, 209, 161, 0.3);
    border-radius: 50%;
    border-top-color: var(--accent);
    animation: spin 1s ease-in-out infinite;
    margin-bottom: 20px;
  }
  
  .loading-text {
    color: var(--muted);
    font-size: 16px;
    text-align: center;
  }
  
  .loading-dots {
    display: inline-block;
    animation: dots 1.5s steps(5, end) infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  @keyframes dots {
    0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0); }
    40% { color: var(--muted); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0); }
    60% { text-shadow: .25em 0 0 var(--muted), .5em 0 0 rgba(0,0,0,0); }
    80%, 100% { text-shadow: .25em 0 0 var(--muted), .5em 0 0 var(--muted); }
  }
  
  /* fixed header */
  header {
    position:fixed; top:0; left:0; right:0; height:56px;
    background:var(--panel); display:flex; align-items:center; justify-content:space-between;
    padding:8px 12px; gap:12px; z-index:20; border-bottom:1px solid rgba(255,255,255,0.03);
  }
  header .title { display:flex; align-items:center; gap:10px; }
  header h1 { font-size:16px; margin:0; color:#e6f7f1; letter-spacing:0.2px; }
  header button { background:none; border:1px solid rgba(255,255,255,0.06); color:var(--muted); padding:6px 10px; border-radius:8px; font-size:13px; }
  /* chat area */
  #chat-wrap { padding:68px 12px 84px; height:100%; overflow:auto; -webkit-overflow-scrolling:touch; }
  .msg-row { display:flex; gap:10px; align-items:flex-start; margin:8px 0; max-width:100%; }
  .msg-row.you { flex-direction:row-reverse; }
  .avatar-small { width:40px; height:40px; border-radius:8px; object-fit:cover; border:1px solid rgba(255,255,255,0.04); cursor:pointer; }
  .bubble { max-width:78%; background:var(--bubble); padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); position:relative; }
  .bubble.you { background:var(--bubble-you); }
  .meta { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:6px; }
  .name { font-weight:700; color:#cfeef0; cursor:pointer; font-size:13px; }
  .time { font-size:11px; color:var(--muted); }
  .text { font-size:15px; color:#e9f3f4; line-height:1.35; word-break:break-word; }
  .bubble img.msg-img { max-width:220px; border-radius:8px; margin-top:8px; display:block; }
  /* fixed input bottom */
  .composer { position:fixed; left:0; right:0; bottom:0; padding:8px 10px; background:var(--panel); display:flex; gap:8px; align-items:center; border-top:1px solid rgba(255,255,255,0.03); z-index:20; }
  .input { flex:1; display:flex; gap:8px; align-items:center; }
  input[type="text"]{ width:100%; padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.04); background:rgba(0,0,0,0.25); color:#fff; outline:none; font-size:15px; }
  button.send { background:var(--accent); color:#012; border:none; padding:10px 12px; border-radius:10px; font-weight:700; cursor:pointer; }
  button.icon { background:#0b0d0f; border:1px solid rgba(255,255,255,0.04); color:var(--muted); padding:8px; border-radius:8px; cursor:pointer; }
  /* profile modal */
  .modal { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.6); z-index:40; visibility:hidden; opacity:0; transition:opacity .12s; }
  .modal.open { visibility:visible; opacity:1; }
  .card { width:92%; max-width:420px; background:#0f1416; border-radius:12px; padding:14px; border:1px solid rgba(255,255,255,0.03); }
  .row { display:flex; gap:12px; align-items:center; }
  .avatar-big { width:84px; height:84px; border-radius:12px; object-fit:cover; border:2px solid rgba(255,255,255,0.04); background: #121a1f; }
  .field { width:100%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:rgba(0,0,0,0.18); color:#fff; outline:none; }
  .muted { color:var(--muted); font-size:13px; margin-top:8px; }
  .row-between { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:10px; }
  .btn { padding:8px 10px; border-radius:8px; border:none; cursor:pointer; }
  .btn.primary { background:var(--accent); color:#022; font-weight:700; }
  .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); }
  
  /* About page styles */
  #aboutPage {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, var(--bg), #071017);
    z-index: 30;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }
  
  #aboutPage.active {
    display: flex;
  }
  
  .about-card {
    background: var(--panel);
    border-radius: 12px;
    padding: 24px;
    max-width: 400px;
    width: 100%;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.03);
  }
  
  .about-title {
    font-size: 24px;
    margin-bottom: 20px;
    color: var(--accent);
  }
  
  .about-content {
    font-size: 16px;
    line-height: 1.5;
    margin-bottom: 24px;
  }
  
  .back-button {
    background: var(--accent);
    color: #012;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    width: 100%;
  }
  
  /* Message actions menu */
  .message-actions {
    position: absolute;
    top: -10px;
    right: 10px;
    background: var(--panel);
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    display: none;
    flex-direction: column;
    overflow: hidden;
    z-index: 10;
  }
  
  .message-actions.show {
    display: flex;
  }
  
  .message-action {
    background: none;
    border: none;
    color: #fff;
    padding: 10px 16px;
    text-align: left;
    cursor: pointer;
    font-size: 14px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .message-action:last-child {
    border-bottom: none;
  }
  
  .message-action:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .message-action.delete {
    color: #ff6b6b;
  }
  
  .message-action.edit {
    color: var(--accent);
  }
  
  /* Edit message input */
  .edit-input {
    width: 100%;
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--accent);
    border-radius: 6px;
    padding: 8px;
    color: #fff;
    font-size: 15px;
    margin: 0;
  }
  
  .edit-buttons {
    display: flex;
    gap: 8px;
    margin-top: 8px;
  }
  
  .edit-buttons button {
    padding: 6px 12px;
    border-radius: 6px;
    border: none;
    font-size: 13px;
    cursor: pointer;
  }
  
  .edit-save {
    background: var(--accent);
    color: #012;
    font-weight: 600;
  }
  
  .edit-cancel {
    background: rgba(255,255,255,0.1);
    color: #fff;
  }
  
  /* Deleted message style */
  .deleted-message {
    font-style: italic;
    color: var(--muted);
    opacity: 0.7;
  }
  
  /* Emoji picker styles */
  .emoji-picker {
    position: fixed;
    bottom: 70px;
    left: 10px;
    background: var(--panel);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    padding: 12px;
    z-index: 25;
    display: none;
    flex-direction: column;
    gap: 8px;
    max-width: 200px;
  }
  
  .emoji-picker.show {
    display: flex;
  }
  
  .emoji-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  
  .emoji-title {
    font-size: 14px;
    color: var(--muted);
  }
  
  .close-emoji {
    background: none;
    border: none;
    color: var(--muted);
    font-size: 18px;
    cursor: pointer;
    padding: 4px;
  }
  
  .emoji-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    border-radius: 8px;
    cursor: pointer;
    border: none;
    background: none;
    color: #fff;
    text-align: left;
    width: 100%;
  }
  
  .emoji-item:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .emoji-img {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    object-fit: cover;
  }
  
  .emoji-name {
    font-size: 14px;
  }
  
  /* Emoji icon in composer */
  .emoji-icon {
    width: 24px;
    height: 24px;
    object-fit: cover;
  }
  
  /* Connection status */
  .connection-status {
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    background: #ff6b6b;
    color: white;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 14px;
    z-index: 35;
    display: none;
    align-items: center;
    gap: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  
  .connection-status.show {
    display: flex;
  }
  
  .connection-status.connected {
    background: var(--accent);
  }
  
  /* small screens */
  @media (max-width:420px){
    .avatar-small{width:36px;height:36px}
    .bubble img.msg-img{max-width:160px}
    header h1{font-size:15px}
    .about-card {
      padding: 20px;
    }
    .message-actions {
      right: 5px;
    }
    .emoji-picker {
      left: 8px;
      right: 8px;
      max-width: none;
    }
    .connection-status {
      top: 56px;
      left: 12px;
      right: 12px;
      transform: none;
    }
  }
</style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loadingScreen">
    <div class="loading-spinner"></div>
    <div class="loading-text">
      Loading chat<span class="loading-dots">...</span>
    </div>
  </div>

  <!-- Connection Status -->
  <div id="connectionStatus" class="connection-status">
    <div class="connection-dot"></div>
    <span>Connecting...</span>
  </div>

  <header>
    <div class="title">
      <svg width="36" height="36" viewBox="0 0 24 24" fill="none" style="border-radius:8px;background:linear-gradient(135deg,#0ea5a3,#1dd1a1);padding:6px">
        <path d="M12 2C7.03 2 3 5.58 3 10c0 2.08.84 3.98 2.22 5.41L3 21l5.88-2.05C10.53 19.44 11.25 19.64 12 19.64c4.97 0 9-3.58 9-8.02S16.97 2 12 2z" fill="#001218"/>
      </svg>
      <h1>Global Chat</h1>
    </div>
    <div>
      <button id="aboutBtn" class="btn ghost">About</button>
      <button id="profileBtn" class="btn ghost">Profile</button>
    </div>
  </header>
  
  <main id="chat-wrap"></main>
  
  <div class="composer">
    <div class="input">
      <input id="messageInput" type="text" placeholder="Type a message..." autocomplete="off" />
    </div>
    <button id="emojiBtn" class="icon" title="Emoji">
      <img src="https://files.catbox.moe/bih7r4.png" class="emoji-icon" alt="Emoji" />
    </button>
    <input id="fileInput" type="file" accept="image/*" style="display:none" />
    <button id="imgBtn" class="icon" title="Send image">üì∑</button>
    <button id="sendBtn" class="send">Send</button>
  </div>

  <!-- Emoji Picker -->
  <div id="emojiPicker" class="emoji-picker">
    <div class="emoji-header">
      <div class="emoji-title">Emojis</div>
      <button class="close-emoji">‚úï</button>
    </div>
    <button class="emoji-item" data-emoji="https://files.catbox.moe/gvhwqz.jpeg" data-name="EZ">
      <img src="https://files.catbox.moe/gvhwqz.jpeg" class="emoji-img" alt="EZ" />
      <span class="emoji-name">EZ</span>
    </button>
  </div>

  <!-- About page -->
  <div id="aboutPage">
    <div class="about-card">
      <h2 class="about-title">About</h2>
      <div class="about-content">
        <p>OWNER: Hack7rBGG / Xymatekidd</p>
        <p>This is a global chat application with user profiles and image sharing capabilities.</p>
      </div>
      <button id="backBtn" class="back-button">Back to Chat</button>
    </div>
  </div>

  <!-- Profile modal -->
  <div id="profileModal" class="modal" aria-hidden="true">
    <div class="card" role="dialog" aria-modal="true">
      <div class="row">
        <img id="profileAvatar" class="avatar-big" src="" alt="avatar preview" />
        <div style="flex:1">
          <input id="nameField" class="field" placeholder="Display name (required)" />
          <textarea id="bioField" class="field" rows="3" placeholder="Short bio (optional)"></textarea>
        </div>
      </div>
      <div style="margin-top:10px;">
        <label class="muted">Choose avatar (file) ‚Äî will be visible to everyone</label>
        <input id="avatarFile" type="file" accept="image/*" style="margin-top:8px" />
      </div>

      <div class="row-between">
        <div>
          <button id="saveProfile" class="btn primary">Save</button>
          <button id="closeProfile" class="btn ghost" style="margin-left:8px">Close</button>
        </div>
        <div class="muted" id="profileTip">Not saved</div>
      </div>
    </div>
  </div>

  <!-- View profile modal -->
  <div id="viewModal" class="modal" aria-hidden="true">
    <div class="card">
      <div style="display:flex;align-items:center;gap:12px">
        <img id="viewAvatar" class="avatar-big" src="" alt="avatar" />
        <div style="flex:1">
          <div id="viewName" style="font-weight:800;font-size:18px"></div>
          <div id="viewBio" class="muted" style="margin-top:6px"></div>
          <div id="viewId" class="muted" style="margin-top:6px;font-size:12px"></div>
        </div>
      </div>
      <div style="display:flex;justify-content:flex-end;margin-top:12px">
        <button id="closeView" class="btn ghost">Close</button>
      </div>
    </div>
  </div>

  <script type="module">
  /* ---------------------------  
    Firebase Realtime DB chat + profiles (base64 avatars)  
    - stores avatars as compressed base64 in /profiles/<uid>/avatar  
    - messages saved in /messages  
    NOTE: For testing set DB rules public:  
    {  
      "rules": { ".read": true, ".write": true }  
    }  
  ---------------------------- */  
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";  
  import { 
    getDatabase, 
    ref, 
    push, 
    onChildAdded, 
    set as dbSet, 
    child, 
    get, 
    query, 
    limitToLast,
    update,
    remove,
    onChildChanged,
    onChildRemoved,
    onDisconnect,
    onValue,
    serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";  
    
  /* ---------- YOUR FIREBASE CONFIG ---------- */  
  const firebaseConfig = {  
    apiKey: "AIzaSyBhBysX0vCpjgBybXAto1eVGJg4BMNPcE",  
    authDomain: "global-chat-4ebaf.firebaseapp.com",  
    databaseURL: "https://global-chat-4ebaf-default-rtdb.firebaseio.com",  
    projectId: "global-chat-4ebaf",  
    storageBucket: "global-chat-4ebaf.appspot.com",  
    messagingSenderId: "932946585758",  
    appId: "1:932946585758:web:299df72156b9222774b93",  
    measurementId: "G-RWRH8RCB0W"  
  };  
  /* ------------------------------------------ */  
    
  const app = initializeApp(firebaseConfig);  
  const db = getDatabase(app);  
    
  /* UI refs */  
  const loadingScreen = document.getElementById('loadingScreen');
  const connectionStatus = document.getElementById('connectionStatus');
  const chatWrap = document.getElementById('chat-wrap');  
  const messageInput = document.getElementById('messageInput');  
  const sendBtn = document.getElementById('sendBtn');  
  const imgBtn = document.getElementById('imgBtn');  
  const fileInput = document.getElementById('fileInput');  
  const emojiBtn = document.getElementById('emojiBtn');  
  const emojiPicker = document.getElementById('emojiPicker');  
  const closeEmoji = document.querySelector('.close-emoji');  
    
  const aboutBtn = document.getElementById('aboutBtn');  
  const aboutPage = document.getElementById('aboutPage');  
  const backBtn = document.getElementById('backBtn');  
    
  const profileBtn = document.getElementById('profileBtn');  
  const profileModal = document.getElementById('profileModal');  
  const nameField = document.getElementById('nameField');  
  const bioField = document.getElementById('bioField');  
  const avatarFile = document.getElementById('avatarFile');  
  const profileAvatar = document.getElementById('profileAvatar');  
  const saveProfile = document.getElementById('saveProfile');  
  const closeProfile = document.getElementById('closeProfile');  
  const profileTip = document.getElementById('profileTip');  
    
  const viewModal = document.getElementById('viewModal');  
  const viewAvatar = document.getElementById('viewAvatar');  
  const viewName = document.getElementById('viewName');  
  const viewBio = document.getElementById('viewBio');  
  const viewId = document.getElementById('viewId');  
  const closeView = document.getElementById('closeView');  
    
  /* local identity */  
  let uid = localStorage.getItem('gc_uid');  
  if (!uid) { uid = 'u' + Date.now().toString(36) + Math.floor(Math.random()*9000); localStorage.setItem('gc_uid', uid); }  
    
  let displayName = localStorage.getItem('gc_name') || ('User' + Math.floor(Math.random()*9000));  
  let displayBio = localStorage.getItem('gc_bio') || '';  
  let displayAvatar = localStorage.getItem('gc_avatar') || ''; // base64 string  
    
  /* Message actions state */
  let currentEditingMessageId = null;
  let messageActionsMenu = null;
  let scrollPositionBeforeEdit = 0;
  let hasMessagesLoaded = false;
  let connectionCheckInterval;
    
  /* Connection monitoring */
  function monitorConnection() {
    const connectedRef = ref(db, '.info/connected');
    onValue(connectedRef, (snap) => {
      if (snap.val() === true) {
        connectionStatus.textContent = 'Connected';
        connectionStatus.classList.add('connected');
        setTimeout(() => {
          connectionStatus.classList.remove('show');
        }, 2000);
      } else {
        connectionStatus.textContent = 'Disconnected - Reconnecting...';
        connectionStatus.classList.remove('connected');
        connectionStatus.classList.add('show');
      }
    });

    // Also check for slow connection
    connectionCheckInterval = setInterval(() => {
      if (!hasMessagesLoaded) {
        connectionStatus.textContent = 'Slow connection - Still loading...';
        connectionStatus.classList.remove('connected');
        connectionStatus.classList.add('show');
      }
    }, 5000);
  }
  
  /* Hide loading screen when messages start loading */
  function hideLoadingScreen() {
    if (!hasMessagesLoaded) {
      hasMessagesLoaded = true;
      setTimeout(() => {
        loadingScreen.classList.add('hidden');
        setTimeout(() => {
          loadingScreen.style.display = 'none';
        }, 300);
      }, 500);
    }
  }
  
  /* Show loading screen when connection is lost */
  function showLoadingScreen() {
    if (!hasMessagesLoaded) {
      loadingScreen.classList.remove('hidden');
      loadingScreen.style.display = 'flex';
    }
  }
  
  /* init UI with stored profile */  
  function refreshProfileUI(){  
    nameField.value = displayName;  
    bioField.value = displayBio;  
    profileAvatar.src = displayAvatar || defaultAvatarSVG();  
  }  
  refreshProfileUI();  
    
  /* helper: default svg avatar (data URL) */  
  function defaultAvatarSVG(){  
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><rect width='100%' height='100%' fill='%23121a1f'/><text x='50%' y='50%' fill='%23fff' font-size='22' text-anchor='middle' dominant-baseline='middle'>Avatar</text></svg>`);  
  }  
    
  /* --- utility: compress image file to base64 (maxWidth, quality) --- */  
  function fileToCompressedDataURL(file, maxWidth=800, quality=0.7){  
    return new Promise((res, rej)=>{  
      const reader = new FileReader();  
      reader.onload = () => {  
        const img = new Image();  
        img.onload = () => {  
          const scale = Math.min(1, maxWidth / img.width);  
          const canvas = document.createElement('canvas');  
          canvas.width = Math.round(img.width * scale);  
          canvas.height = Math.round(img.height * scale);  
          const ctx = canvas.getContext('2d');  
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);  
          const mime = 'image/jpeg';  
          const dataUrl = canvas.toDataURL(mime, quality);  
          res(dataUrl);  
        };  
        img.onerror = e => rej(e);  
        img.src = reader.result;  
      };  
      reader.onerror = e => rej(e);  
      reader.readAsDataURL(file);  
    });  
  }  
    
  /* --- Save profile to Realtime DB under /profiles/<uid> --- */  
  async function saveProfileToDB(){  
    profileTip.textContent = 'Saving...';  
    try {  
      await dbSet(ref(db, `profiles/${uid}`), {  
        name: displayName,  
        bio: displayBio,  
        avatar: displayAvatar || ''  
      });  
      localStorage.setItem('gc_name', displayName);  
      localStorage.setItem('gc_bio', displayBio);  
      if (displayAvatar) localStorage.setItem('gc_avatar', displayAvatar);  
      profileTip.textContent = 'Saved';  
      setTimeout(()=> profileTip.textContent = 'Saved ‚úì', 800);  
    } catch(err){  
      console.error(err); profileTip.textContent = 'Save failed';  
    }  
  }  
    
  /* About page handlers */
  aboutBtn.onclick = () => { 
    aboutPage.classList.add('active'); 
  };
  
  backBtn.onclick = () => { 
    aboutPage.classList.remove('active'); 
  };
  
  /* Emoji picker handlers */
  emojiBtn.addEventListener('click', () => {
    emojiPicker.classList.toggle('show');
  });
  
  closeEmoji.addEventListener('click', () => {
    emojiPicker.classList.remove('show');
  });
  
  // Close emoji picker when clicking outside
  document.addEventListener('click', (e) => {
    if (!emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
      emojiPicker.classList.remove('show');
    }
  });
  
  // Emoji item click handler
  document.querySelectorAll('.emoji-item').forEach(item => {
    item.addEventListener('click', () => {
      const emojiUrl = item.dataset.emoji;
      sendMessage(emojiUrl);
      emojiPicker.classList.remove('show');
    });
  });
    
  /* profile modal handlers */  
  profileBtn.onclick = () => { profileModal.classList.add('open'); profileModal.setAttribute('aria-hidden','false'); refreshProfileUI(); };  
  closeProfile.onclick = ()=> { profileModal.classList.remove('open'); profileModal.setAttribute('aria-hidden','true'); };  
  profileModal.addEventListener('click', e => { if (e.target === profileModal) closeProfile.click(); });  
    
  avatarFile.addEventListener('change', async (e)=>{  
    const f = e.target.files && e.target.files[0];  
    if (!f) return;  
    try {  
      profileAvatar.src = ''; // while compressing  
      const dataUrl = await fileToCompressedDataURL(f, 600, 0.7);  
      displayAvatar = dataUrl;  
      profileAvatar.src = displayAvatar;  
      profileTip.textContent = 'Preview updated';  
    } catch(err){ console.error(err); alert('Avatar processing failed'); }  
  });  
    
  /* save profile */  
  saveProfile.addEventListener('click', async ()=>{  
    const newName = (nameField.value || '').trim();  
    const newBio = (bioField.value || '').trim();  
    if (!newName) return alert('Please enter a display name');  
    displayName = newName; displayBio = newBio;  
    await saveProfileToDB();  
    closeProfile.click();  
  });  
    
  /* --- send message (text or with uploaded image) --- */  
  async function sendMessage(imageDataUrl = null){  
    const text = (messageInput.value || '').trim();  
    if (!text && !imageDataUrl) return;  
    
    // Check if it's an emoji URL
    const isEmoji = imageDataUrl && imageDataUrl.includes('catbox.moe');
    
    const payload = {  
      uid,  
      name: displayName,  
      avatar: displayAvatar || '',  
      bio: displayBio || '',  
      text: isEmoji ? '' : text,  
      image: imageDataUrl || null,  
      time: Date.now(),  
      edited: false,
      deleted: false,
      isEmoji: !!isEmoji
    };  
    try {  
      await push(ref(db, 'messages'), payload);  
      messageInput.value = '';  
    } catch(err){  
      console.error('send failed', err);  
      alert('Failed to send message');  
    }  
  }  
    
  /* send button */  
  sendBtn.addEventListener('click', ()=> sendMessage());  
  messageInput.addEventListener('keydown', e=> { if (e.key === 'Enter') sendMessage(); });  
    
  /* image send via file chooser (compress -> send) */  
  imgBtn.addEventListener('click', ()=> fileInput.click());  
  fileInput.addEventListener('change', async (e)=>{  
    const f = e.target.files && e.target.files[0];  
    if (!f) return;  
    // quick placeholder  
    const placeholder = createLocalPlaceholder('Uploading image...');  
    try {  
      const dataUrl = await fileToCompressedDataURL(f, 1000, 0.7); // compressed  
      placeholder.remove();  
      await sendMessage(dataUrl);  
    } catch(err){ console.error(err); placeholder.remove(); alert('Image upload failed'); }  
    fileInput.value = '';  
  });  
    
  /* helper: create a temporary uploading message placeholder */  
  function createLocalPlaceholder(text){  
    const row = document.createElement('div');  
    row.className = 'msg-row you';  
    row.innerHTML = `<div class="avatar-small"></div><div class="bubble you"><div class="meta"><div class="name">You</div><div class="time">...</div></div><div class="text">${text}</div></div>`;  
    chatWrap.appendChild(row);  
    chatWrap.scrollTop = chatWrap.scrollHeight;  
    return row;  
  }  
    
  /* --- listen for messages (last 400) --- */  
  const lastQ = query(ref(db,'messages'), limitToLast(400));  
  onChildAdded(lastQ, snap => {  
    const m = snap.val();  
    if (!m) return;  
    hideLoadingScreen();
    renderMessage(m, snap.key);  
  });

  // Listen for message updates
  onChildChanged(lastQ, snap => {
    const m = snap.val();
    if (!m) return;
    renderMessage(m, snap.key);
  });

  // Listen for message deletions
  onChildRemoved(lastQ, snap => {
    const messageElement = document.querySelector(`[data-message-id="${snap.key}"]`);
    if (messageElement) {
      messageElement.remove();
    }
  });
  
  /* render message element */  
  function renderMessage(m, messageId){  
    // Check if message already exists
    const existingMessage = document.querySelector(`[data-message-id="${messageId}"]`);
    if (existingMessage) {
      existingMessage.remove();
    }

    // Don't render deleted messages
    if (m.deleted) return;
    
    const row = document.createElement('div');  
    row.className = 'msg-row' + (m.uid === uid ? ' you' : '');  
    row.setAttribute('data-message-id', messageId);
    
    // avatar img  
    const avatarEl = document.createElement('img');  
    avatarEl.className = 'avatar-small';  
    avatarEl.src = m.avatar || defaultAvatarSVG();  
    avatarEl.addEventListener('click', ()=> openProfile(m.uid));  
    
    // bubble  
    const bubble = document.createElement('div');  
    bubble.className = 'bubble' + (m.uid === uid ? ' you' : '');  
    
    const time = new Date(m.time || Date.now()).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});  
    const nameHtml = `<span class="name" data-uid="${escapeHtml(m.uid)}">${escapeHtml(m.name || 'User')}</span>`;  
    
    // Handle emoji messages
    let contentHtml = '';
    if (m.isEmoji && m.image) {
      contentHtml = `<img class="msg-img" src="${escapeHtml(m.image)}" alt="emoji" style="max-width: 100px;">`;
    } else if (m.image) {
      contentHtml = `<img class="msg-img" src="${escapeHtml(m.image)}" alt="img">`;
    }
    
    // Check if this message is being edited
    let messageContent = '';
    if (currentEditingMessageId === messageId) {
      // Show edit input if this message is being edited - INLINE editing
      messageContent = `
        <div class="text">
          <input type="text" class="edit-input" value="${escapeHtml(m.text||'')}" />
        </div>
        <div class="edit-buttons">
          <button class="edit-save">Save</button>
          <button class="edit-cancel">Cancel</button>
        </div>
      `;
    } else {
      messageContent = `<div class="text">${escapeHtml(m.text||'')} ${m.edited ? '<span style="font-size:11px;color:var(--muted);">(edited)</span>' : ''}</div>`;
    }
    
    bubble.innerHTML = `
      <div class="meta">
        <div>${nameHtml}</div>
        <div class="time">${time} ${m.edited ? '‚úèÔ∏è' : ''}</div>
      </div>
      ${messageContent}
      ${contentHtml}
    `;
    
    // Add message actions menu for user's own text messages (not emojis)
    if (m.uid === uid && !m.deleted && !m.isEmoji) {
      const actionsMenu = document.createElement('div');
      actionsMenu.className = 'message-actions';
      actionsMenu.innerHTML = `
        <button class="message-action edit">‚úèÔ∏è Edit</button>
        <button class="message-action delete">üóëÔ∏è Delete for me</button>
        <button class="message-action delete">üö´ Delete for everyone</button>
      `;
      bubble.appendChild(actionsMenu);
      
      // Add click event for showing menu (removed long press)
      bubble.addEventListener('click', (e) => {
        // Don't show menu if clicking on links or other interactive elements
        if (e.target.tagName === 'A' || e.target.classList.contains('name') || e.target.classList.contains('edit-input')) return;
        
        // Show menu on message click
        showMessageActions(actionsMenu, messageId, m);
      });
      
      bubble.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showMessageActions(actionsMenu, messageId, m);
      });
    }
    
    // name click -> open profile  
    bubble.querySelectorAll('.name').forEach(n => n.addEventListener('click', ()=> openProfile(n.dataset.uid)));  
    
    // Edit button handlers if in edit mode
    if (currentEditingMessageId === messageId) {
      const editInput = bubble.querySelector('.edit-input');
      const saveBtn = bubble.querySelector('.edit-save');
      const cancelBtn = bubble.querySelector('.edit-cancel');
      
      const saveEdit = () => {
        updateMessage(messageId, editInput.value);
      };
      
      const cancelEdit = () => {
        currentEditingMessageId = null;
        // Restore scroll position after edit
        setTimeout(() => {
          chatWrap.scrollTop = scrollPositionBeforeEdit;
        }, 50);
        renderMessage(m, messageId); // Re-render without edit mode
      };
      
      saveBtn.addEventListener('click', saveEdit);
      cancelBtn.addEventListener('click', cancelEdit);
      
      editInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          saveEdit();
        } else if (e.key === 'Escape') {
          cancelEdit();
        }
      });
      
      editInput.focus();
      editInput.select();
      
      // Keep the message in the same position during edit
      const messageRect = row.getBoundingClientRect();
      const chatRect = chatWrap.getBoundingClientRect();
      if (messageRect.bottom > chatRect.bottom || messageRect.top < chatRect.top) {
        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
    
    row.appendChild(avatarEl);  
    row.appendChild(bubble);  
    chatWrap.appendChild(row);  
    
    // limit render length  
    while (chatWrap.children.length > 800) chatWrap.removeChild(chatWrap.firstChild);  
    
    // Only scroll to bottom if it's a new message, not when editing
    if (currentEditingMessageId !== messageId && !existingMessage) {
      chatWrap.scrollTop = chatWrap.scrollHeight;
    }
  }
  
  /* Show message actions menu */
  function showMessageActions(menu, messageId, message) {
    // Hide any other open menus
    document.querySelectorAll('.message-actions.show').forEach(m => {
      m.classList.remove('show');
    });
    
    menu.classList.add('show');
    
    // Position the menu
    const rect = menu.parentElement.getBoundingClientRect();
    menu.style.top = `${-10}px`;
    menu.style.right = `${10}px`;
    
    // Add event listeners to action buttons
    const editBtn = menu.querySelector('.message-action.edit');
    const deleteForMeBtn = menu.querySelectorAll('.message-action.delete')[0];
    const deleteForEveryoneBtn = menu.querySelectorAll('.message-action.delete')[1];
    
    // Remove existing event listeners by cloning
    const newEditBtn = editBtn.cloneNode(true);
    const newDeleteForMeBtn = deleteForMeBtn.cloneNode(true);
    const newDeleteForEveryoneBtn = deleteForEveryoneBtn.cloneNode(true);
    
    editBtn.parentNode.replaceChild(newEditBtn, editBtn);
    deleteForMeBtn.parentNode.replaceChild(newDeleteForMeBtn, deleteForMeBtn);
    deleteForEveryoneBtn.parentNode.replaceChild(newDeleteForEveryoneBtn, deleteForEveryoneBtn);
    
    // Edit message
    newEditBtn.addEventListener('click', () => {
      // Save current scroll position before editing
      scrollPositionBeforeEdit = chatWrap.scrollTop;
      currentEditingMessageId = messageId;
      renderMessage(message, messageId);
      menu.classList.remove('show');
    });
    
    // Delete for me only (remove from DB)
    newDeleteForMeBtn.addEventListener('click', () => {
      if (confirm('Delete this message for yourself?')) {
        deleteMessageForMe(messageId);
      }
      menu.classList.remove('show');
    });
    
    // Delete for everyone
    newDeleteForEveryoneBtn.addEventListener('click', () => {
      if (confirm('Delete this message for everyone? This cannot be undone.')) {
        deleteMessageForEveryone(messageId);
      }
      menu.classList.remove('show');
    });
    
    // Close menu when clicking outside
    const closeMenuHandler = (e) => {
      if (!menu.contains(e.target)) {
        menu.classList.remove('show');
        document.removeEventListener('click', closeMenuHandler);
      }
    };
    
    setTimeout(() => {
      document.addEventListener('click', closeMenuHandler);
    }, 10);
  }
  
  /* Update message text */
  async function updateMessage(messageId, newText) {
    if (!newText.trim()) return;
    
    try {
      await update(ref(db, `messages/${messageId}`), {
        text: newText.trim(),
        edited: true,
        editTime: Date.now()
      });
      currentEditingMessageId = null;
      // Restore scroll position after saving edit
      setTimeout(() => {
        chatWrap.scrollTop = scrollPositionBeforeEdit;
      }, 50);
    } catch(err) {
      console.error('Failed to update message:', err);
      alert('Failed to update message');
    }
  }
  
  /* Delete message for me only */
  async function deleteMessageForMe(messageId) {
    try {
      // Simply remove the message from the database
      await remove(ref(db, `messages/${messageId}`));
    } catch(err) {
      console.error('Failed to delete message:', err);
      alert('Failed to delete message');
    }
  }
  
  /* Delete message for everyone */
  async function deleteMessageForEveryone(messageId) {
    try {
      await update(ref(db, `messages/${messageId}`), {
        deleted: true,
        text: '[This message was deleted]',
        image: null
      });
    } catch(err) {
      console.error('Failed to delete message for everyone:', err);
      alert('Failed to delete message for everyone');
    }
  }
    
  /* open public profile viewer - reads /profiles/<uid> */  
  async function openProfile(viewUid){  
    if (!viewUid) return;  
    try {  
      const snap = await get(child(ref(db), `profiles/${viewUid}`));  
      const p = snap.exists() ? snap.val() : null;  
      // fallback local if your own and not saved in DB  
      if (!p && viewUid === uid) {  
        viewAvatar.src = displayAvatar || defaultAvatarSVG();  
        viewName.textContent = displayName;  
        viewBio.textContent = displayBio || '';  
        viewId.textContent = `id: ${viewUid}`;  
        viewModal.classList.add('open'); return;  
      }  
      viewAvatar.src = (p && p.avatar) ? p.avatar : defaultAvatarSVG();  
      viewName.textContent = (p && p.name) ? p.name : 'Unknown';  
      viewBio.textContent = (p && p.bio) ? p.bio : '';  
      viewId.textContent = `id: ${viewUid}`;  
      viewModal.classList.add('open');  
    } catch(err){ console.error(err); alert('Failed to load profile'); }  
  }  
  closeView.addEventListener('click', ()=> viewModal.classList.remove('open'));  
    
  /* escape helper */  
  function escapeHtml(s=''){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }  
    
  /* initialize ‚Äî save local profile to DB if not present */  
  (async function init(){  
    // Start connection monitoring
    monitorConnection();
    
    // if local avatar exists but not saved in DB, write profile  
    try {  
      const snap = await get(child(ref(db), `profiles/${uid}`));  
      if (!snap.exists()){  
        await dbSet(ref(db, `profiles/${uid}`), { name: displayName, bio: displayBio, avatar: displayAvatar || '' });  
      } else {  
        // if DB profile exists, use it to populate local  
        const p = snap.val();  
        if (p.name) { 
          displayName = p.name; 
          localStorage.setItem('gc_name', displayName); 
          nameField.value = displayName; 
        }  
        if (p.bio)  { 
          displayBio = p.bio; 
          localStorage.setItem('gc_bio', displayBio); 
          bioField.value = displayBio; 
        }  
        if (p.avatar){ 
          displayAvatar = p.avatar; 
          localStorage.setItem('gc_avatar', displayAvatar); 
        }  
      }  
    } catch(err){ 
      console.warn('init profile read failed', err); 
      // Show connection error
      connectionStatus.textContent = 'Connection failed - Check your internet';
      connectionStatus.classList.remove('connected');
      connectionStatus.classList.add('show');
    }  
    refreshProfileUI();  
    
    // Hide loading screen after timeout (fallback)
    setTimeout(() => {
      hideLoadingScreen();
    }, 10000);
  })();  
  </script>
</body>
  </html>
