<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Global Chat ‚Äî Hack7rBGG / Xymatekidd</title>
<meta name="description" content="Mobile global chat with profiles (avatars via file upload saved to Realtime DB)" />
<style>
  :root{
    --bg:#0d0f12; --panel:#121417; --accent:#1dd1a1; --muted:#9aa3ab;
    --bubble:#1b1d20; --bubble-you:#06394a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,var(--bg),#071017);color:#fff}
  /* Loading screen */
  #loadingScreen {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, var(--bg), #071017);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }
  
  #loadingScreen.hidden {
    display: none;
  }
  
  .loading-spinner {
    width: 50px;
    height: 50px;
    border: 3px solid rgba(29, 209, 161, 0.3);
    border-radius: 50%;
    border-top-color: var(--accent);
    animation: spin 1s ease-in-out infinite;
    margin-bottom: 20px;
  }
  
  .loading-text {
    color: var(--muted);
    font-size: 16px;
    text-align: center;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  /* fixed header */
  header {
    position:fixed; top:0; left:0; right:0; height:56px;
    background:var(--panel); display:flex; align-items:center; justify-content:space-between;
    padding:8px 12px; gap:12px; z-index:20; border-bottom:1px solid rgba(255,255,255,0.03);
  }
  header .title { display:flex; align-items:center; gap:10px; }
  header h1 { font-size:16px; margin:0; color:#e6f7f1; letter-spacing:0.2px; }
  header button { background:none; border:1px solid rgba(255,255,255,0.06); color:var(--muted); padding:6px 10px; border-radius:8px; font-size:13px; }
  header .header-buttons { display:flex; gap:8px; align-items:center; }
  
  /* chat area */
  #chat-wrap { padding:68px 12px 84px; height:100%; overflow:auto; -webkit-overflow-scrolling:touch; }
  .msg-row { display:flex; gap:10px; align-items:flex-start; margin:8px 0; max-width:100%; }
  .msg-row.you { flex-direction:row-reverse; }
  .avatar-small { width:40px; height:40px; border-radius:8px; object-fit:cover; border:1px solid rgba(255,255,255,0.04); cursor:pointer; }
  .bubble { max-width:78%; background:var(--bubble); padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); position:relative; }
  .bubble.you { background:var(--bubble-you); }
  .meta { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:6px; }
  .name { font-weight:700; color:#cfeef0; cursor:pointer; font-size:13px; }
  .time { font-size:11px; color:var(--muted); }
  .text { font-size:15px; color:#e9f3f4; line-height:1.35; word-break:break-word; }
  .bubble img.msg-img { max-width:220px; border-radius:8px; margin-top:8px; display:block; }
  /* fixed input bottom */
  .composer { position:fixed; left:0; right:0; bottom:0; padding:8px 10px; background:var(--panel); display:flex; gap:8px; align-items:center; border-top:1px solid rgba(255,255,255,0.03); z-index:20; }
  .input { flex:1; display:flex; gap:8px; align-items:center; }
  input[type="text"]{ width:100%; padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.04); background:rgba(0,0,0,0.25); color:#fff; outline:none; font-size:15px; }
  button.send { background:var(--accent); color:#012; border:none; padding:10px 12px; border-radius:10px; font-weight:700; cursor:pointer; }
  button.icon { background:#0b0d0f; border:1px solid rgba(255,255,255,0.04); color:var(--muted); padding:8px; border-radius:8px; cursor:pointer; }
  /* profile modal */
  .modal { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.6); z-index:40; visibility:hidden; opacity:0; transition:opacity .12s; }
  .modal.open { visibility:visible; opacity:1; }
  .card { width:92%; max-width:420px; background:#0f1416; border-radius:12px; padding:14px; border:1px solid rgba(255,255,255,0.03); }
  .row { display:flex; gap:12px; align-items:center; }
  .avatar-big { width:84px; height:84px; border-radius:12px; object-fit:cover; border:2px solid rgba(255,255,255,0.04); background: #121a1f; }
  .field { width:100%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:rgba(0,0,0,0.18); color:#fff; outline:none; }
  .muted { color:var(--muted); font-size:13px; margin-top:8px; }
  .row-between { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:10px; }
  .btn { padding:8px 10px; border-radius:8px; border:none; cursor:pointer; }
  .btn.primary { background:var(--accent); color:#022; font-weight:700; }
  .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); }
  
  /* Owner badge style */
  .owner-badge {
    background: linear-gradient(135deg, #ff6b6b, #ffa726);
    color: #fff;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 700;
    margin-left: 6px;
  }
  
  /* About page styles */
  #aboutPage {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, var(--bg), #071017);
    z-index: 30;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }
  
  #aboutPage.active {
    display: flex;
  }
  
  .about-card {
    background: var(--panel);
    border-radius: 12px;
    padding: 24px;
    max-width: 400px;
    width: 100%;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.03);
  }
  
  .about-title {
    font-size: 24px;
    margin-bottom: 20px;
    color: var(--accent);
  }
  
  .about-content {
    font-size: 16px;
    line-height: 1.5;
    margin-bottom: 24px;
  }
  
  .back-button {
    background: var(--accent);
    color: #012;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    width: 100%;
  }
  
  /* Message actions menu */
  .message-actions {
    position: absolute;
    top: -10px;
    right: 10px;
    background: var(--panel);
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    display: none;
    flex-direction: column;
    overflow: hidden;
    z-index: 10;
  }
  
  .message-actions.show {
    display: flex;
  }
  
  .message-action {
    background: none;
    border: none;
    color: #fff;
    padding: 10px 16px;
    text-align: left;
    cursor: pointer;
    font-size: 14px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .message-action:last-child {
    border-bottom: none;
  }
  
  .message-action:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .message-action.delete {
    color: #ff6b6b;
  }
  
  .message-action.edit {
    color: var(--accent);
  }
  
  .message-action.reply {
    color: #4dabf7;
  }
  
  /* Edit message input */
  .edit-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .edit-input {
    width: 100%;
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--accent);
    border-radius: 6px;
    padding: 8px;
    color: #fff;
    font-size: 15px;
    margin: 0;
    font-family: inherit;
    line-height: inherit;
  }
  
  .edit-buttons {
    display: flex;
    gap: 8px;
  }
  
  .edit-buttons button {
    padding: 6px 12px;
    border-radius: 6px;
    border: none;
    font-size: 13px;
    cursor: pointer;
  }
  
  .edit-save {
    background: var(--accent);
    color: #012;
    font-weight: 600;
  }
  
  .edit-cancel {
    background: rgba(255,255,255,0.1);
    color: #fff;
  }
  
  /* Deleted message style */
  .deleted-message {
    font-style: italic;
    color: var(--muted);
    opacity: 0.7;
  }
  
  /* Emoji picker styles */
  .emoji-picker {
    position: fixed;
    bottom: 70px;
    left: 10px;
    background: var(--panel);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    padding: 12px;
    z-index: 25;
    display: none;
    flex-direction: column;
    gap: 8px;
    max-width: 200px;
  }
  
  .emoji-picker.show {
    display: flex;
  }
  
  .emoji-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  
  .emoji-title {
    font-size: 14px;
    color: var(--muted);
  }
  
  .close-emoji {
    background: none;
    border: none;
    color: var(--muted);
    font-size: 18px;
    cursor: pointer;
    padding: 4px;
  }
  
  .emoji-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    border-radius: 8px;
    cursor: pointer;
    border: none;
    background: none;
    color: #fff;
    text-align: left;
    width: 100%;
  }
  
  .emoji-item:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .emoji-img {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    object-fit: cover;
  }
  
  .emoji-name {
    font-size: 14px;
  }
  
  /* Emoji icon in composer */
  .emoji-icon {
    width: 24px;
    height: 24px;
    object-fit: cover;
  }
  
  /* Reply styles */
  .reply-container {
    background: rgba(255,255,255,0.05);
    border-radius: 6px;
    padding: 6px 8px;
    margin-bottom: 6px;
    border-left: 2px solid var(--accent);
    cursor: pointer;
  }
  
  .reply-container:hover {
    background: rgba(255,255,255,0.08);
  }
  
  .reply-author {
    font-size: 12px;
    color: var(--accent);
    font-weight: 600;
  }
  
  .reply-text {
    font-size: 13px;
    color: var(--muted);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  /* Reply indicator */
  .reply-indicator {
    position: fixed;
    bottom: 60px;
    left: 10px;
    right: 10px;
    background: var(--panel);
    border: 1px solid var(--accent);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 14px;
    color: var(--muted);
    z-index: 21;
  }
  
  /* Link styles */
  .chat-link {
    color: var(--accent);
    text-decoration: none;
    border-bottom: 1px dotted var(--accent);
    word-break: break-all;
  }
  
  .chat-link:hover {
    color: #4dabf7;
    border-bottom: 1px solid #4dabf7;
  }
  
  /* Link preview modal */
  .link-preview-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 50;
    padding: 20px;
  }
  
  .link-preview-card {
    background: var(--panel);
    border-radius: 12px;
    padding: 20px;
    max-width: 500px;
    width: 100%;
    border: 1px solid rgba(255,255,255,0.06);
  }
  
  .link-preview-title {
    font-size: 18px;
    margin-bottom: 12px;
    color: var(--accent);
  }
  
  .link-preview-url {
    font-size: 14px;
    color: var(--muted);
    margin-bottom: 16px;
    word-break: break-all;
  }
  
  .link-preview-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
  }
  
  .link-preview-buttons button {
    padding: 8px 16px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: 600;
  }
  
  .link-preview-open {
    background: var(--accent);
    color: #012;
  }
  
  .link-preview-cancel {
    background: rgba(255,255,255,0.1);
    color: #fff;
  }
  
  /* Blood name styles */
  .blood-name {
    background: linear-gradient(90deg, #ff0000, #ff3333, #ff0000);
    background-size: 200% 100%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: bloodPulse 2s infinite;
    font-weight: 800;
    text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
    position: relative;
    display: inline-block;
  }
  
  .blood-name::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    width: 100%;
    height: 2px;
    background: linear-gradient(90deg, transparent, #ff0000, transparent);
    animation: bloodLine 3s infinite;
  }
  
  @keyframes bloodPulse {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
  }
  
  @keyframes bloodLine {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 1; }
  }
  
  .blood-badge {
    background: linear-gradient(135deg, #ff0000, #cc0000);
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 700;
    margin-left: 6px;
    animation: bloodBadge 2s infinite;
  }
  
  @keyframes bloodBadge {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  
  /* Bot message style */
  .bot-message {
    background: rgba(29, 209, 161, 0.1);
    border: 1px solid rgba(29, 209, 161, 0.3);
  }
  
  .bot-name {
    color: var(--accent);
    font-weight: 700;
  }
  
  /* small screens */
  @media (max-width:420px){
    .avatar-small{width:36px;height:36px}
    .bubble img.msg-img{max-width:160px}
    header h1{font-size:15px}
    .about-card {
      padding: 20px;
    }
    .message-actions {
      right: 5px;
    }
    .emoji-picker {
      left: 8px;
      right: 8px;
      max-width: none;
    }
    .header-buttons {
      gap: 6px;
    }
    .link-preview-card {
      padding: 16px;
    }
  }
</style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loadingScreen">
    <div class="loading-spinner"></div>
    <div class="loading-text">
      Loading chat...
    </div>
  </div>

  <header>
    <div class="title">
      <svg width="36" height="36" viewBox="0 0 24 24" fill="none" style="border-radius:8px;background:linear-gradient(135deg,#0ea5a3,#1dd1a1);padding:6px">
        <path d="M12 2C7.03 2 3 5.58 3 10c0 2.08.84 3.98 2.22 5.41L3 21l5.88-2.05C10.53 19.44 11.25 19.64 12 19.64c4.97 0 9-3.58 9-8.02S16.97 2 12 2z" fill="#001218"/>
      </svg>
      <h1>Global Chat</h1>
    </div>
    <div class="header-buttons">
      <button id="aboutBtn" class="btn ghost">About</button>
      <button id="profileBtn" class="btn ghost">Profile</button>
    </div>
  </header>
  
  <main id="chat-wrap"></main>
  
  <div class="composer">
    <div class="input">
      <input id="messageInput" type="text" placeholder="Type a message..." autocomplete="off" />
    </div>
    <button id="emojiBtn" class="icon" title="Emoji">
      <img src="https://files.catbox.moe/bih7r4.png" class="emoji-icon" alt="Emoji" />
    </button>
    <input id="fileInput" type="file" accept="image/*" style="display:none" />
    <button id="imgBtn" class="icon" title="Send image">üì∑</button>
    <button id="sendBtn" class="send">Send</button>
  </div>

  <!-- Emoji Picker -->
  <div id="emojiPicker" class="emoji-picker">
    <div class="emoji-header">
      <div class="emoji-title">Emojis</div>
      <button class="close-emoji">‚úï</button>
    </div>
    <button class="emoji-item" data-emoji="https://files.catbox.moe/gvhwqz.jpeg" data-name="EZ">
      <img src="https://files.catbox.moe/gvhwqz.jpeg" class="emoji-img" alt="EZ" />
      <span class="emoji-name">EZ</span>
    </button>
    <button class="emoji-item" data-emoji="https://files.catbox.moe/9oxpbw.jpg" data-name="Cryüò≠">
      <img src="https://files.catbox.moe/9oxpbw.jpg" class="emoji-img" alt="Cryüò≠" />
      <span class="emoji-name">Cryüò≠</span>
    </button>
  </div>

  <!-- Link Preview Modal -->
  <div id="linkPreviewModal" class="link-preview-modal" style="display: none;">
    <div class="link-preview-card">
      <h3 class="link-preview-title">Open Link</h3>
      <p class="link-preview-url" id="previewUrl"></p>
      <div class="link-preview-buttons">
        <button id="cancelLink" class="link-preview-cancel">Cancel</button>
        <button id="openLink" class="link-preview-open">Open Link</button>
      </div>
    </div>
  </div>

  <!-- About page -->
  <div id="aboutPage">
    <div class="about-card">
      <h2 class="about-title">About</h2>
      <div class="about-content">
        <p>OWNER: Hack7rBGG / Xymatekidd</p>
        <p>This is a global chat application with user profiles and image sharing capabilities.</p>
      </div>
      <button id="backBtn" class="back-button">Back to Chat</button>
    </div>
  </div>

  <!-- Profile modal -->
  <div id="profileModal" class="modal" aria-hidden="true">
    <div class="card" role="dialog" aria-modal="true">
      <div class="row">
        <img id="profileAvatar" class="avatar-big" src="" alt="avatar preview" />
        <div style="flex:1">
          <input id="nameField" class="field" placeholder="Display name (required)" />
          <textarea id="bioField" class="field" rows="3" placeholder="Short bio (optional)"></textarea>
        </div>
      </div>

      <div style="margin-top:10px;">
        <label class="muted">Choose avatar (file) ‚Äî will be visible to everyone</label>
        <input id="avatarFile" type="file" accept="image/*" style="margin-top:8px" />
      </div>

      <div class="row-between">
        <div>
          <button id="saveProfile" class="btn primary">Save</button>
          <button id="closeProfile" class="btn ghost" style="margin-left:8px">Close</button>
        </div>
        <div class="muted" id="profileTip">Not saved</div>
      </div>
    </div>
  </div>

  <!-- View profile modal -->
  <div id="viewModal" class="modal" aria-hidden="true">
    <div class="card">
      <div style="display:flex;align-items:center;gap:12px">
        <img id="viewAvatar" class="avatar-big" src="" alt="avatar" />
        <div style="flex:1">
          <div id="viewName" style="font-weight:800;font-size:18px"></div>
          <div id="viewBio" class="muted" style="margin-top:6px"></div>
          <div id="viewId" class="muted" style="margin-top:6px;font-size:12px"></div>
        </div>
      </div>
      <div style="display:flex;justify-content:flex-end;margin-top:12px">
        <button id="closeView" class="btn ghost">Close</button>
      </div>
    </div>
  </div>

  <script type="module">
  /* ---------------------------  
    Firebase Realtime DB chat + profiles (base64 avatars)  
  ---------------------------- */  
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";  
  import { 
    getDatabase, 
    ref, 
    push, 
    onChildAdded, 
    set as dbSet, 
    child, 
    get, 
    query, 
    limitToLast,
    update,
    remove,
    onChildChanged,
    onChildRemoved
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";  
    
  /* ---------- YOUR FIREBASE CONFIG ---------- */  
  const firebaseConfig = {  
    apiKey: "AIzaSyBhBysX0vCpjgBybXAto1eVGJg4BMNPcE",  
    authDomain: "global-chat-4ebaf.firebaseapp.com",  
    databaseURL: "https://global-chat-4ebaf-default-rtdb.firebaseio.com",  
    projectId: "global-chat-4ebaf",  
    storageBucket: "global-chat-4ebaf.appspot.com",  
    messagingSenderId: "932946585758",  
    appId: "1:932946585758:web:299df72156b9222774b93",  
    measurementId: "G-RWRH8RCB0W"  
  };  
  /* ------------------------------------------ */  
    
  const app = initializeApp(firebaseConfig);  
  const db = getDatabase(app);  
    
  /* UI refs */  
  const loadingScreen = document.getElementById('loadingScreen');
  const chatWrap = document.getElementById('chat-wrap');  
  const messageInput = document.getElementById('messageInput');  
  const sendBtn = document.getElementById('sendBtn');  
  const imgBtn = document.getElementById('imgBtn');  
  const fileInput = document.getElementById('fileInput');  
  const emojiBtn = document.getElementById('emojiBtn');  
  const emojiPicker = document.getElementById('emojiPicker');  
  const closeEmoji = document.querySelector('.close-emoji');  
    
  const aboutBtn = document.getElementById('aboutBtn');  
  const aboutPage = document.getElementById('aboutPage');  
  const backBtn = document.getElementById('backBtn');  
    
  const profileBtn = document.getElementById('profileBtn');  
  const profileModal = document.getElementById('profileModal');  
  const nameField = document.getElementById('nameField');  
  const bioField = document.getElementById('bioField');  
  const avatarFile = document.getElementById('avatarFile');  
  const profileAvatar = document.getElementById('profileAvatar');  
  const saveProfile = document.getElementById('saveProfile');  
  const closeProfile = document.getElementById('closeProfile');  
  const profileTip = document.getElementById('profileTip');  
    
  const viewModal = document.getElementById('viewModal');  
  const viewAvatar = document.getElementById('viewAvatar');  
  const viewName = document.getElementById('viewName');  
  const viewBio = document.getElementById('viewBio');  
  const viewId = document.getElementById('viewId');  
  const closeView = document.getElementById('closeView');  
    
  // Link preview elements
  const linkPreviewModal = document.getElementById('linkPreviewModal');
  const previewUrl = document.getElementById('previewUrl');
  const cancelLink = document.getElementById('cancelLink');
  const openLink = document.getElementById('openLink');
    
  /* local identity */  
  let uid = localStorage.getItem('gc_uid');  
  if (!uid) { 
    uid = 'u' + Date.now().toString(36) + Math.floor(Math.random()*9000); 
    localStorage.setItem('gc_uid', uid); 
  }  
    
  // Generate random name for new users
  const randomNames = ['Shadow', 'Neon', 'Cyber', 'Phantom', 'Vector', 'Nova', 'Echo', 'Zenith', 'Orbit', 'Quantum', 'Pixel', 'Matrix'];
  const randomName = randomNames[Math.floor(Math.random() * randomNames.length)] + Math.floor(Math.random() * 1000);
  
  let displayName = localStorage.getItem('gc_name') || randomName;  
  let displayBio = localStorage.getItem('gc_bio') || '';  
  let displayAvatar = localStorage.getItem('gc_avatar') || 'https://files.catbox.moe/jignnb.jpeg';
    
  /* Message actions state */
  let currentEditingMessageId = null;
  let replyingToMessageId = null;
  let repliedMessageData = null;
  let lastMessageTime = 0;
  let notificationPermissionAsked = localStorage.getItem('gc_notification_asked') === 'true';
  
  // Owner ID
  const OWNER_ID = "umhxfqwb87908";
  
  // Blood name command user ID - CHANGED TO umhyqguft3765
  const BLOOD_COMMAND_USER_ID = "umhxfqwb87908";
  
  // Blood name active users storage
  let bloodNameUsers = JSON.parse(localStorage.getItem('gc_blood_names') || '{}');

  // Debug functions
  window.forceSetUserId = function(newUserId) {
    uid = newUserId;
    localStorage.setItem('gc_uid', uid);
    console.log('üîÑ FORCED USER ID CHANGE TO:', uid);
    console.log('Now you are authorized?', uid === BLOOD_COMMAND_USER_ID);
    location.reload();
  };

  window.debugBloodCommand = function() {
    console.log('=== DEBUG COMMAND STATUS ===');
    console.log('Current User ID:', uid);
    console.log('Required User ID:', BLOOD_COMMAND_USER_ID);
    console.log('Authorized:', uid === BLOOD_COMMAND_USER_ID);
    console.log('Blood Names:', bloodNameUsers);
    
    if (uid === BLOOD_COMMAND_USER_ID) {
      console.log('‚úÖ YOU ARE AUTHORIZED! Commands should work.');
    } else {
      console.log('‚ùå YOU ARE NOT AUTHORIZED! You need to be user:', BLOOD_COMMAND_USER_ID);
      console.log('üí° Try this in console: forceSetUserId("umhyqguft3765")');
    }
  };
  
  /* Automatically request notification permission for new visitors */
  function autoRequestNotificationPermission() {
    if ("Notification" in window && 
        !notificationPermissionAsked && 
        Notification.permission === "default") {
      
      setTimeout(() => {
        Notification.requestPermission().then(permission => {
          localStorage.setItem('gc_notification_asked', 'true');
          notificationPermissionAsked = true;
          
          if (permission === "granted") {
            console.log("Notification permission granted automatically");
            showTemporaryMessage("üîî Notifications enabled! You'll get notified for replies.");
            
            setTimeout(() => {
              showNotification("Global Chat", "Welcome! You'll now get notifications for new messages and replies.");
            }, 1000);
          }
        }).catch(err => {
          console.error("Auto notification permission error:", err);
        });
      }, 2000);
    }
  }
  
  /* Show temporary message */
  function showTemporaryMessage(message) {
    const tempMsg = document.createElement('div');
    tempMsg.style.cssText = `
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: #012;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 600;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    tempMsg.textContent = message;
    document.body.appendChild(tempMsg);
    
    setTimeout(() => {
      tempMsg.remove();
    }, 3000);
  }
  
  /* Show notification */
  function showNotification(title, body, tag = '') {
    if ("Notification" in window && Notification.permission === "granted" && !document.hasFocus()) {
      const options = {
        body: body,
        icon: "https://files.catbox.moe/jignnb.jpeg",
        tag: tag || 'global-chat',
        requireInteraction: false
      };
      
      try {
        const notification = new Notification(title, options);
        
        setTimeout(() => {
          notification.close();
        }, 5000);
        
        notification.onclick = () => {
          window.focus();
          notification.close();
        };
      } catch (err) {
        console.error('Notification error:', err);
      }
    }
  }
  
  /* Hide loading screen */
  function hideLoadingScreen() {
    loadingScreen.classList.add('hidden');
  }
  
  /* init UI with stored profile */  
  function refreshProfileUI(){  
    nameField.value = displayName;  
    bioField.value = displayBio;  
    profileAvatar.src = displayAvatar;  
  }  
    
  /* helper: default svg avatar (data URL) */  
  function defaultAvatarSVG(){  
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><rect width='100%' height='100%' fill='%23121a1f'/><text x='50%' y='50%' fill='%23fff' font-size='22' text-anchor='middle' dominant-baseline='middle'>Avatar</text></svg>`);  
  }  
    
  /* --- utility: compress image file to base64 (maxWidth, quality) --- */  
  function fileToCompressedDataURL(file, maxWidth=800, quality=0.7){  
    return new Promise((res, rej)=>{  
      const reader = new FileReader();  
      reader.onload = () => {  
        const img = new Image();  
        img.onload = () => {  
          const scale = Math.min(1, maxWidth / img.width);  
          const canvas = document.createElement('canvas');  
          canvas.width = Math.round(img.width * scale);  
          canvas.height = Math.round(img.height * scale);  
          const ctx = canvas.getContext('2d');  
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);  
          const mime = 'image/jpeg';  
          const dataUrl = canvas.toDataURL(mime, quality);  
          res(dataUrl);  
        };  
        img.onerror = e => rej(e);  
        img.src = reader.result;  
      };  
      reader.onerror = e => rej(e);  
      reader.readAsDataURL(file);  
    });  
  }  
    
  /* --- Save profile to Realtime DB under /profiles/<uid> --- */  
  async function saveProfileToDB(){  
    profileTip.textContent = 'Saving...';  
    try {  
      await dbSet(ref(db, `profiles/${uid}`), {  
        name: displayName,  
        bio: displayBio,  
        avatar: displayAvatar || ''  
      });  
      localStorage.setItem('gc_name', displayName);  
      localStorage.setItem('gc_bio', displayBio);  
      if (displayAvatar) localStorage.setItem('gc_avatar', displayAvatar);  
      profileTip.textContent = 'Saved';  
      setTimeout(()=> profileTip.textContent = 'Saved ‚úì', 800);  
    } catch(err){  
      console.error(err); profileTip.textContent = 'Save failed';  
    }  
  }  
    
  /* Blood name command system */
  function handleBloodCommand(messageText, senderUid) {
    console.log('üîç Checking blood command:', messageText, 'from user:', senderUid);
    
    // Check if sender is authorized to use blood command
    if (senderUid !== BLOOD_COMMAND_USER_ID) {
        console.log('‚ùå User not authorized for blood command. Required:', BLOOD_COMMAND_USER_ID, 'Got:', senderUid);
        sendBotMessage(`‚ùå Only user ${BLOOD_COMMAND_USER_ID} can use blood commands.`);
        return false;
    }
    
    // Parse command: /give USER_ID BloodName
    const commandMatch = messageText.match(/^\/give\s+(\w+)\s+BloodName$/);
    if (!commandMatch) {
        console.log('‚ùå Invalid command format. Use: /give USER_ID BloodName');
        sendBotMessage('‚ùå Invalid command format. Use: /give USER_ID BloodName');
        return false;
    }
    
    const targetUserId = commandMatch[1];
    
    console.log('üéØ Target user:', targetUserId);
    
    // Don't allow giving blood name to yourself
    if (targetUserId === senderUid) {
        console.log('‚ùå Cannot give blood name to yourself');
        sendBotMessage('‚ùå You cannot give a blood name to yourself!');
        return false;
    }
    
    // Set blood name with 24-hour expiry - ALWAYS "BloodName"
    const expiryTime = Date.now() + (24 * 60 * 60 * 1000); // 24 hours
    bloodNameUsers[targetUserId] = {
        name: "BloodName", // ALWAYS "BloodName"
        expiry: expiryTime,
        givenBy: senderUid,
        givenAt: Date.now()
    };
    
    // Save to localStorage
    localStorage.setItem('gc_blood_names', JSON.stringify(bloodNameUsers));
    
    console.log('‚úÖ Blood name saved:', bloodNameUsers[targetUserId]);
    
    // Send bot messages
    sendBotMessage(`ü©∏ BLOOD NAME ACTIVATED! User ${targetUserId} received the BloodName! It will expire in 24 hours.`);
    sendBotMessage(`‚è∞ YOUR BLOOD COLOUR NAME WILL FINISH AT 24 HOUR START NOW!`);
    
    // Show success message to user
    showTemporaryMessage(`‚úÖ BloodName given to ${targetUserId}!`);
    
    return true;
  }
  
  /* Check and remove expired blood names */
  function checkBloodNameExpiry() {
    const now = Date.now();
    let expiredUsers = [];
    
    for (const [userId, data] of Object.entries(bloodNameUsers)) {
      if (now > data.expiry) {
        expiredUsers.push(userId);
      }
    }
    
    // Remove expired users and send notifications
    expiredUsers.forEach(userId => {
      delete bloodNameUsers[userId];
      sendBotMessage(`ü©∏ THE BLOOD COLOUR NAME FOR USER ${userId} HAS FINISHED!`);
    });
    
    if (expiredUsers.length > 0) {
      localStorage.setItem('gc_blood_names', JSON.stringify(bloodNameUsers));
    }
  }
  
  /* Get blood name for user */
  function getBloodName(userId) {
    const bloodData = bloodNameUsers[userId];
    if (!bloodData) return null;
    
    // Check if expired
    if (Date.now() > bloodData.expiry) {
      delete bloodNameUsers[userId];
      localStorage.setItem('gc_blood_names', JSON.stringify(bloodNameUsers));
      return null;
    }
    
    return bloodData.name;
  }
  
  /* Send bot message */
  async function sendBotMessage(text) {
    const payload = {  
      uid: 'BOT',  
      name: 'System Bot',  
      avatar: 'https://files.catbox.moe/jignnb.jpeg',  
      bio: '',  
      text: text,  
      image: null,  
      time: Date.now(),  
      edited: false,
      deleted: false,
      isEmoji: false,
      replyTo: null,
      replyToName: null,
      replyToText: null,
      replyToUid: null,
      isBot: true
    };  
    
    try {  
      await push(ref(db, 'messages'), payload);  
    } catch(err){  
      console.error('Bot message failed', err);  
    }  
  }
  
  /* Event Listeners */
  
  aboutBtn.onclick = () => { 
    aboutPage.classList.add('active'); 
  };
  
  backBtn.onclick = () => { 
    aboutPage.classList.remove('active'); 
  };
  
  /* Emoji picker handlers */
  emojiBtn.addEventListener('click', () => {
    emojiPicker.classList.toggle('show');
  });
  
  closeEmoji.addEventListener('click', () => {
    emojiPicker.classList.remove('show');
  });
  
  // Close emoji picker when clicking outside
  document.addEventListener('click', (e) => {
    if (!emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
      emojiPicker.classList.remove('show');
    }
  });
  
  // Emoji item click handler
  document.querySelectorAll('.emoji-item').forEach(item => {
    item.addEventListener('click', () => {
      const emojiUrl = item.dataset.emoji;
      sendMessage(emojiUrl);
      emojiPicker.classList.remove('show');
    });
  });
  
  /* Link preview handlers */
  cancelLink.addEventListener('click', () => {
    linkPreviewModal.style.display = 'none';
  });
  
  openLink.addEventListener('click', () => {
    const url = previewUrl.textContent;
    window.open(url, '_blank', 'noopener,noreferrer');
    linkPreviewModal.style.display = 'none';
  });
  
  // Close link preview when clicking outside
  linkPreviewModal.addEventListener('click', (e) => {
    if (e.target === linkPreviewModal) {
      linkPreviewModal.style.display = 'none';
    }
  });
    
  /* profile modal handlers */  
  profileBtn.onclick = () => { 
    profileModal.classList.add('open'); 
    profileModal.setAttribute('aria-hidden','false'); 
    refreshProfileUI(); 
  };  
  closeProfile.onclick = ()=> { profileModal.classList.remove('open'); profileModal.setAttribute('aria-hidden','true'); };  
  profileModal.addEventListener('click', e => { if (e.target === profileModal) closeProfile.click(); });  
    
  avatarFile.addEventListener('change', async (e)=>{  
    const f = e.target.files && e.target.files[0];  
    if (!f) return;  
    try {  
      profileAvatar.src = ''; // while compressing  
      const dataUrl = await fileToCompressedDataURL(f, 600, 0.7);  
      displayAvatar = dataUrl;  
      profileAvatar.src = displayAvatar;  
      profileTip.textContent = 'Preview updated';  
    } catch(err){ console.error(err); alert('Avatar processing failed'); }  
  });  
    
  /* save profile */  
  saveProfile.addEventListener('click', async ()=>{  
    const newName = (nameField.value || '').trim();  
    const newBio = (bioField.value || '').trim();  
    if (!newName) return alert('Please enter a display name');  
    displayName = newName; displayBio = newBio;  
    await saveProfileToDB();  
    closeProfile.click();  
  });  
    
  /* --- send message (text or with uploaded image) --- */  
  async function sendMessage(imageDataUrl = null){  
    const text = (messageInput.value || '').trim();  
    console.log('üì§ Sending message:', text, 'from user:', uid);
    
    if (!text && !imageDataUrl && !replyingToMessageId) return;  
    
    // Check for blood command FIRST before sending the message
    if (text.startsWith('/give')) {
        console.log('ü©∏ Blood command detected');
        if (handleBloodCommand(text, uid)) {
            console.log('‚úÖ Blood command processed successfully - NOT sending as regular message');
            messageInput.value = '';
            return; // Don't send the command as a regular message
        } else {
            console.log('‚ùå Blood command failed - sending as regular message');
            // Continue to send as regular message if command failed
        }
    }
    
    // Check if it's an emoji URL
    const isEmoji = imageDataUrl && imageDataUrl.includes('catbox.moe');
    
    const payload = {  
      uid,  
      name: displayName,  
      avatar: displayAvatar || '',  
      bio: displayBio || '',  
      text: isEmoji ? '' : text,  
      image: imageDataUrl || null,  
      time: Date.now(),  
      edited: false,
      deleted: false,
      isEmoji: !!isEmoji,
      replyTo: replyingToMessageId || null,
      replyToName: repliedMessageData?.name || null,
      replyToText: repliedMessageData?.text || null,
      replyToUid: repliedMessageData?.uid || null
    };  
    try {  
      await push(ref(db, 'messages'), payload);  
      messageInput.value = '';  
      replyingToMessageId = null;
      repliedMessageData = null;
      // Clear reply indicator if any
      const replyIndicator = document.querySelector('.reply-indicator');
      if (replyIndicator) replyIndicator.remove();
    } catch(err){  
      console.error('send failed', err);  
      alert('Failed to send message');  
    }  
  }  
    
  /* send button */  
  sendBtn.addEventListener('click', ()=> sendMessage());  
  messageInput.addEventListener('keydown', e=> { 
    if (e.key === 'Enter') {
      sendMessage(); 
    }
  });  
    
  /* image send via file chooser (compress -> send) */  
  imgBtn.addEventListener('click', ()=> fileInput.click());  
  fileInput.addEventListener('change', async (e)=>{  
    const f = e.target.files && e.target.files[0];  
    if (!f) return;  
    // quick placeholder  
    const placeholder = createLocalPlaceholder('Uploading image...');  
    try {  
      const dataUrl = await fileToCompressedDataURL(f, 1000, 0.7); // compressed  
      placeholder.remove();  
      await sendMessage(dataUrl);  
    } catch(err){ console.error(err); placeholder.remove(); alert('Image upload failed'); }  
    fileInput.value = '';  
  });  
    
  /* helper: create a temporary uploading message placeholder */  
  function createLocalPlaceholder(text){  
    const row = document.createElement('div');  
    row.className = 'msg-row you';  
    row.innerHTML = `<div class="avatar-small"></div><div class="bubble you"><div class="meta"><div class="name">You</div><div class="time">...</div></div><div class="text">${text}</div></div>`;  
    chatWrap.appendChild(row);  
    chatWrap.scrollTop = chatWrap.scrollHeight;  
    return row;  
  }  
    
  /* --- listen for messages (last 400) --- */  
  const lastQ = query(ref(db,'messages'), limitToLast(400));  
  onChildAdded(lastQ, snap => {  
    const m = snap.val();  
    if (!m) return;  
    
    // Show notification for new messages (except your own and if page is not focused)
    if (m.uid !== uid && !document.hasFocus() && m.time > lastMessageTime) {
      let notificationTitle = `${m.name}`;
      let notificationBody = '';
      let notificationTag = 'new-message';
      
      // Check if this is a reply to the current user
      if (m.replyToUid === uid) {
        notificationTitle = `‚Ü©Ô∏è ${m.name} replied to you`;
        notificationBody = m.text || 'Sent an image';
        notificationTag = 'reply';
      } else if (m.replyTo && m.replyToName) {
        notificationBody = `Replying to ${m.replyToName}: ${m.text || 'Sent an image'}`;
      } else if (m.isEmoji) {
        notificationBody = 'sent an emoji';
      } else {
        notificationBody = m.text || 'sent an image';
      }
      
      showNotification(notificationTitle, notificationBody, notificationTag);
    }
    lastMessageTime = Math.max(lastMessageTime, m.time);
    
    hideLoadingScreen();
    renderMessage(m, snap.key);  
  });

  // Listen for message updates
  onChildChanged(lastQ, snap => {
    const m = snap.val();
    if (!m) return;
    renderMessage(m, snap.key);
  });

  // Listen for message deletions
  onChildRemoved(lastQ, snap => {
    const messageElement = document.querySelector(`[data-message-id="${snap.key}"]`);
    if (messageElement) {
      messageElement.remove();
    }
  });
  
  /* URL detection and link creation */
  function detectURLs(text) {
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    return text.replace(urlRegex, (url) => {
      return `<a href="${url}" class="chat-link" target="_blank" rel="noopener noreferrer">${url}</a>`;
    });
  }
  
  /* Show link preview confirmation */
  function showLinkPreview(url) {
    previewUrl.textContent = url;
    linkPreviewModal.style.display = 'flex';
  }
  
  /* render message element */  
  function renderMessage(m, messageId){  
    // Check if message already exists
    const existingMessage = document.querySelector(`[data-message-id="${messageId}"]`);
    
    // If we're editing this message and it already exists, DON'T recreate it
    if (currentEditingMessageId === messageId && existingMessage) {
      // Just update the existing message content without moving it
      const bubble = existingMessage.querySelector('.bubble');
      const time = new Date(m.time || Date.now()).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});  
      
      // Check if user is owner and show "OWNER" badge
      let nameHtml;
      if (m.uid === OWNER_ID) {
        nameHtml = `<span class="name" data-uid="${escapeHtml(m.uid)}">${escapeHtml(m.name || 'User')}<span class="owner-badge">OWNER</span></span>`;
      } else {
        nameHtml = `<span class="name" data-uid="${escapeHtml(m.uid)}">${escapeHtml(m.name || 'User')}</span>`;
      }
      
      // Handle emoji messages
      let contentHtml = '';
      if (m.isEmoji && m.image) {
        contentHtml = `<img class="msg-img" src="${escapeHtml(m.image)}" alt="emoji" style="max-width: 100px;">`;
      } else if (m.image) {
        contentHtml = `<img class="msg-img" src="${escapeHtml(m.image)}" alt="img">`;
      }
      
      // Handle reply
      let replyHtml = '';
      if (m.replyTo && m.replyToName) {
        replyHtml = `<div class="reply-container" data-reply-to="${m.replyTo}">
          <div class="reply-author">Replying to ${escapeHtml(m.replyToName)}</div>
          <div class="reply-text">${escapeHtml(m.replyToText || '')}</div>
        </div>`;
      }
      
      // Update the bubble content for edit mode
      bubble.innerHTML = `
        <div class="meta">
          <div>${nameHtml}</div>
          <div class="time">${time} ${m.edited ? '‚úèÔ∏è' : ''}</div>
        </div>
        ${replyHtml}
        <div class="edit-container">
          <input type="text" class="edit-input" value="${escapeHtml(m.text||'')}" />
          <div class="edit-buttons">
            <button class="edit-save">Save</button>
            <button class="edit-cancel">Cancel</button>
          </div>
        </div>
        ${contentHtml}
      `;
      
      // Re-attach edit event handlers
      const editInput = bubble.querySelector('.edit-input');
      const saveBtn = bubble.querySelector('.edit-save');
      const cancelBtn = bubble.querySelector('.edit-cancel');
      
      const saveEdit = () => {
        updateMessage(messageId, editInput.value);
      };
      
      const cancelEdit = () => {
        currentEditingMessageId = null;
        renderMessage(m, messageId);
      };
      
      saveBtn.addEventListener('click', saveEdit);
      cancelBtn.addEventListener('click', cancelEdit);
      
      editInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          saveEdit();
        } else if (e.key === 'Escape') {
          cancelEdit();
        }
      });
      
      // Focus and select after a small delay to ensure the element is rendered
      setTimeout(() => {
        editInput.focus();
        editInput.select();
      }, 10);
      
      return;
    }

    // Don't render deleted messages
    if (m.deleted) return;
    
    const row = document.createElement('div');  
    row.className = 'msg-row' + (m.uid === uid ? ' you' : '');  
    row.setAttribute('data-message-id', messageId);
    
    // avatar img  
    const avatarEl = document.createElement('img');  
    avatarEl.className = 'avatar-small';  
    avatarEl.src = m.avatar || 'https://files.catbox.moe/jignnb.jpeg';  
    avatarEl.addEventListener('click', ()=> openProfile(m.uid));  
    
    // bubble  
    const bubble = document.createElement('div');  
    bubble.className = 'bubble' + (m.uid === uid ? ' you' : '');  
    if (m.isBot) {
      bubble.classList.add('bot-message');
    }
    
    const time = new Date(m.time || Date.now()).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});  
    
    // Check blood name
    const bloodName = getBloodName(m.uid);
    
    // Check if user is owner and show "OWNER" badge
    let nameHtml;
    if (m.isBot) {
      nameHtml = `<span class="bot-name" data-uid="${escapeHtml(m.uid)}">${escapeHtml(m.name || 'System Bot')}</span>`;
    } else if (m.uid === OWNER_ID) {
      nameHtml = `<span class="name" data-uid="${escapeHtml(m.uid)}">${escapeHtml(m.name || 'User')}<span class="owner-badge">OWNER</span></span>`;
    } else if (bloodName) {
      nameHtml = `<span class="blood-name" data-uid="${escapeHtml(m.uid)}">${escapeHtml(m.name || 'User')}<span class="blood-badge">${escapeHtml(bloodName)}</span></span>`;
    } else {
      nameHtml = `<span class="name" data-uid="${escapeHtml(m.uid)}">${escapeHtml(m.name || 'User')}</span>`;
    }
    
    // Handle emoji messages
    let contentHtml = '';
    if (m.isEmoji && m.image) {
      contentHtml = `<img class="msg-img" src="${escapeHtml(m.image)}" alt="emoji" style="max-width: 100px;">`;
    } else if (m.image) {
      contentHtml = `<img class="msg-img" src="${escapeHtml(m.image)}" alt="img">`;
    }
    
    // Handle reply
    let replyHtml = '';
    if (m.replyTo && m.replyToName) {
      replyHtml = `<div class="reply-container" data-reply-to="${m.replyTo}">
        <div class="reply-author">Replying to ${escapeHtml(m.replyToName)}</div>
        <div class="reply-text">${escapeHtml(m.replyToText || '')}</div>
      </div>`;
    }
    
    // Check if this message is being edited
    let messageContent = '';
    if (currentEditingMessageId === messageId) {
      // Show edit input
      messageContent = `
        <div class="edit-container">
          <input type="text" class="edit-input" value="${escapeHtml(m.text||'')}" />
          <div class="edit-buttons">
            <button class="edit-save">Save</button>
            <button class="edit-cancel">Cancel</button>
          </div>
        </div>
      `;
    } else {
      // Convert URLs to clickable links
      const textWithLinks = m.text ? detectURLs(escapeHtml(m.text)) : '';
      messageContent = `<div class="text">${textWithLinks} ${m.edited ? '<span style="font-size:11px;color:var(--muted);">(edited)</span>' : ''}</div>`;
    }
    
    bubble.innerHTML = `
      <div class="meta">
        <div>${nameHtml}</div>
        <div class="time">${time} ${m.edited ? '‚úèÔ∏è' : ''}</div>
      </div>
      ${replyHtml}
      ${messageContent}
      ${contentHtml}
    `;
    
    // Add click handler for reply container to scroll to original message
    if (m.replyTo) {
      const replyContainer = bubble.querySelector('.reply-container');
      if (replyContainer) {
        replyContainer.addEventListener('click', () => {
          const originalMessage = document.querySelector(`[data-message-id="${m.replyTo}"]`);
          if (originalMessage) {
            originalMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Add highlight effect
            originalMessage.style.backgroundColor = 'rgba(29, 209, 161, 0.1)';
            setTimeout(() => {
              originalMessage.style.backgroundColor = '';
            }, 2000);
          }
        });
      }
    }
    
    // Add click handlers for links to show preview
    const links = bubble.querySelectorAll('.chat-link');
    links.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        showLinkPreview(link.href);
      });
    });
    
    // Add message actions menu for user's own messages (not for bot messages)
    if (m.uid === uid && !m.deleted && currentEditingMessageId !== messageId && !m.isBot) {
      const actionsMenu = document.createElement('div');
      actionsMenu.className = 'message-actions';
      
      // Different options for emoji vs text messages
      if (m.isEmoji) {
        actionsMenu.innerHTML = `
          <button class="message-action delete">üóëÔ∏è Delete for me only</button>
          <button class="message-action delete">üö´ Delete for everyone</button>
        `;
      } else {
        actionsMenu.innerHTML = `
          <button class="message-action edit">‚úèÔ∏è Edit</button>
          <button class="message-action reply">‚Ü©Ô∏è Reply</button>
          <button class="message-action delete">üóëÔ∏è Delete for me only</button>
          <button class="message-action delete">üö´ Delete for everyone</button>
        `;
      }
      
      bubble.appendChild(actionsMenu);
      
      // Add HOLD gesture for showing menu (NOT CLICK)
      let holdTimer;
      let isHolding = false;
      
      const startHold = (e) => {
        // Don't trigger on name clicks or if already holding
        if (e.target.classList.contains('name') || isHolding) return;
        
        holdTimer = setTimeout(() => {
          isHolding = true;
          showMessageActions(actionsMenu, messageId, m);
        }, 500); // 500ms hold
      };
      
      const endHold = () => {
        clearTimeout(holdTimer);
        isHolding = false;
      };
      
      // Mouse events
      bubble.addEventListener('mousedown', startHold);
      bubble.addEventListener('mouseup', endHold);
      bubble.addEventListener('mouseleave', endHold);
      
      // Touch events
      bubble.addEventListener('touchstart', startHold);
      bubble.addEventListener('touchend', endHold);
      bubble.addEventListener('touchcancel', endHold);
      
      // Prevent context menu on hold
      bubble.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });
    }
    
    // Add actions menu for other people's messages (reply only, not for bot messages)
    if (m.uid !== uid && !m.deleted && currentEditingMessageId !== messageId && !m.isBot) {
      const actionsMenu = document.createElement('div');
      actionsMenu.className = 'message-actions';
      actionsMenu.innerHTML = `
        <button class="message-action reply">‚Ü©Ô∏è Reply</button>
      `;
      
      bubble.appendChild(actionsMenu);
      
      // Add HOLD gesture for showing menu
      let holdTimer;
      let isHolding = false;
      
      const startHold = (e) => {
        if (e.target.classList.contains('name') || isHolding) return;
        
        holdTimer = setTimeout(() => {
          isHolding = true;
          showMessageActions(actionsMenu, messageId, m);
        }, 500);
      };
      
      const endHold = () => {
        clearTimeout(holdTimer);
        isHolding = false;
      };
      
      bubble.addEventListener('mousedown', startHold);
      bubble.addEventListener('mouseup', endHold);
      bubble.addEventListener('mouseleave', endHold);
      
      bubble.addEventListener('touchstart', startHold);
      bubble.addEventListener('touchend', endHold);
      bubble.addEventListener('touchcancel', endHold);
      
      bubble.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });
    }
    
    // name click -> open profile (not for bot messages)
    if (!m.isBot) {
      bubble.querySelectorAll('.name, .blood-name').forEach(n => n.addEventListener('click', ()=> openProfile(n.dataset.uid)));  
    }
    
    // Edit button handlers if in edit mode (for new messages)
    if (currentEditingMessageId === messageId) {
      const editInput = bubble.querySelector('.edit-input');
      const saveBtn = bubble.querySelector('.edit-save');
      const cancelBtn = bubble.querySelector('.edit-cancel');
      
      const saveEdit = () => {
        updateMessage(messageId, editInput.value);
      };
      
      const cancelEdit = () => {
        currentEditingMessageId = null;
        renderMessage(m, messageId);
      };
      
      saveBtn.addEventListener('click', saveEdit);
      cancelBtn.addEventListener('click', cancelEdit);
      
      editInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          saveEdit();
        } else if (e.key === 'Escape') {
          cancelEdit();
        }
      });
      
      // Focus and select after a small delay to ensure the element is rendered
      setTimeout(() => {
        editInput.focus();
        editInput.select();
      }, 10);
    }
    
    row.appendChild(avatarEl);  
    row.appendChild(bubble);  
    
    // If message already exists, replace it (except when editing)
    if (existingMessage && currentEditingMessageId !== messageId) {
      existingMessage.parentNode.replaceChild(row, existingMessage);
    } else if (!existingMessage) {
      chatWrap.appendChild(row);  
    }
    
    // limit render length  
    while (chatWrap.children.length > 800) chatWrap.removeChild(chatWrap.firstChild);  
    
    // Only scroll to bottom if it's a new message, not when editing
    if (currentEditingMessageId !== messageId && !existingMessage) {
      chatWrap.scrollTop = chatWrap.scrollHeight;
    }
  }
  
  /* Show message actions menu */
  function showMessageActions(menu, messageId, message) {
    // Hide any other open menus
    document.querySelectorAll('.message-actions.show').forEach(m => {
      m.classList.remove('show');
    });
    
    menu.classList.add('show');
    
    // Position the menu
    const rect = menu.parentElement.getBoundingClientRect();
    menu.style.top = `${-10}px`;
    menu.style.right = `${10}px`;
    
    // Add event listeners to action buttons
    const editBtn = menu.querySelector('.message-action.edit');
    const replyBtn = menu.querySelector('.message-action.reply');
    const deleteForMeBtn = menu.querySelectorAll('.message-action.delete')[0];
    const deleteForEveryoneBtn = menu.querySelectorAll('.message-action.delete')[1];
    
    // Remove existing event listeners by cloning
    if (editBtn) {
      const newEditBtn = editBtn.cloneNode(true);
      editBtn.parentNode.replaceChild(newEditBtn, editBtn);
      newEditBtn.addEventListener('click', () => {
        currentEditingMessageId = messageId;
        renderMessage(message, messageId);
        menu.classList.remove('show');
      });
    }
    
    if (replyBtn) {
      const newReplyBtn = replyBtn.cloneNode(true);
      replyBtn.parentNode.replaceChild(newReplyBtn, replyBtn);
      newReplyBtn.addEventListener('click', () => {
        replyingToMessageId = messageId;
        repliedMessageData = {
          name: message.name,
          text: message.text,
          uid: message.uid
        };
        // Show reply indicator
        showReplyIndicator(message);
        menu.classList.remove('show');
      });
    }
    
    if (deleteForMeBtn) {
      const newDeleteForMeBtn = deleteForMeBtn.cloneNode(true);
      deleteForMeBtn.parentNode.replaceChild(newDeleteForMeBtn, deleteForMeBtn);
      newDeleteForMeBtn.addEventListener('click', () => {
        if (confirm('Delete this message for yourself only?')) {
          deleteMessageForMe(messageId);
        }
        menu.classList.remove('show');
      });
    }
    
    if (deleteForEveryoneBtn) {
      const newDeleteForEveryoneBtn = deleteForEveryoneBtn.cloneNode(true);
      deleteForEveryoneBtn.parentNode.replaceChild(newDeleteForEveryoneBtn, deleteForEveryoneBtn);
      newDeleteForEveryoneBtn.addEventListener('click', () => {
        if (confirm('Delete this message for everyone? This cannot be undone.')) {
          deleteMessageForEveryone(messageId);
        }
        menu.classList.remove('show');
      });
    }
    
    // Close menu when clicking outside
    const closeMenuHandler = (e) => {
      if (!menu.contains(e.target)) {
        menu.classList.remove('show');
        document.removeEventListener('click', closeMenuHandler);
      }
    };
    
    setTimeout(() => {
      document.addEventListener('click', closeMenuHandler);
    }, 10);
  }
  
  /* Show reply indicator */
  function showReplyIndicator(message) {
    // Remove existing indicator
    const existingIndicator = document.querySelector('.reply-indicator');
    if (existingIndicator) existingIndicator.remove();
    
    const indicator = document.createElement('div');
    indicator.className = 'reply-indicator';
    indicator.style.cssText = `
      position: fixed;
      bottom: 60px;
      left: 10px;
      right: 10px;
      background: var(--panel);
      border: 1px solid var(--accent);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 14px;
      color: var(--muted);
      z-index: 21;
    `;
    
    const text = message.isEmoji ? 'Emoji' : (message.text || 'Image');
    indicator.innerHTML = `
      Replying to ${message.name}: ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}
      <button style="float:right;background:none;border:none;color:var(--muted);cursor:pointer;">‚úï</button>
    `;
    
    document.body.appendChild(indicator);
    
    // Cancel reply
    indicator.querySelector('button').addEventListener('click', () => {
      indicator.remove();
      replyingToMessageId = null;
      repliedMessageData = null;
    });
    
    // Auto focus input
    messageInput.focus();
  }
  
  /* Update message text */
  async function updateMessage(messageId, newText) {
    if (!newText.trim()) return;
    
    try {
      // Use the working syntax from old code
      const updates = {};
      updates['text'] = newText.trim();
      updates['edited'] = true;
      updates['editTime'] = Date.now();
      
      await update(ref(db, 'messages/' + messageId), updates);
      currentEditingMessageId = null;
    } catch(err) {
      console.error('Failed to update message:', err);
      alert('Failed to update message');
    }
  }
  
  /* Delete message for me only - ONLY REMOVES FROM MY VIEW */
  async function deleteMessageForMe(messageId) {
    try {
      // Just remove the message element from the DOM without touching Firebase
      const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
      if (messageElement) {
        messageElement.remove();
      }
    } catch(err) {
      console.error('Failed to delete message for me:', err);
      alert('Failed to delete message for yourself');
    }
  }
  
  /* Delete message for everyone - FIXED WITH WORKING SYNTAX */
  async function deleteMessageForEveryone(messageId) {
    try {
      // Use the exact same syntax from your working old code
      const updates = {};
      updates['deleted'] = true;
      updates['text'] = '[This message was deleted]';
      updates['image'] = null;
      updates['deleteTime'] = Date.now();
      updates['deletedBy'] = uid;
      
      await update(ref(db, 'messages/' + messageId), updates);
      console.log('Message deleted for everyone:', messageId);
    } catch(err) {
      console.error('Failed to delete message for everyone:', err);
      alert('Failed to delete message for everyone: ' + err.message);
    }
  }
    
  /* open public profile viewer - reads /profiles/<uid> */  
  async function openProfile(viewUid){  
    if (!viewUid) return;  
    try {  
      const snap = await get(child(ref(db), `profiles/${viewUid}`));  
      const p = snap.exists() ? snap.val() : null;  
      // fallback local if your own and not saved in DB  
      if (!p && viewUid === uid) {  
        viewAvatar.src = displayAvatar || 'https://files.catbox.moe/jignnb.jpeg';  
        viewName.textContent = displayName;  
        viewBio.textContent = displayBio || '';  
        viewId.textContent = `id: ${viewUid}`;  
        viewModal.classList.add('open'); return;  
      }  
      viewAvatar.src = (p && p.avatar) ? p.avatar : 'https://files.catbox.moe/jignnb.jpeg';  
      viewName.textContent = (p && p.name) ? p.name : 'Unknown';  
      viewBio.textContent = (p && p.bio) ? p.bio : '';  
      viewId.textContent = `id: ${viewUid}`;  
      viewModal.classList.add('open');  
    } catch(err){ console.error(err); alert('Failed to load profile'); }  
  }  
  closeView.addEventListener('click', ()=> viewModal.classList.remove('open'));  
    
  /* escape helper */  
  function escapeHtml(s=''){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }  
    
  /* initialize ‚Äî save local profile to DB if not present */  
  (async function init(){  
    // Hide loading screen immediately
    hideLoadingScreen();
    
    // Automatically request notification permission for new visitors
    autoRequestNotificationPermission();
    
    // Check blood name expiry on startup
    checkBloodNameExpiry();
    
    // Check blood name expiry every minute
    setInterval(checkBloodNameExpiry, 60000);
    
    // if local avatar exists but not saved in DB, write profile  
    try {  
      const snap = await get(child(ref(db), `profiles/${uid}`));  
      if (!snap.exists()){  
        await dbSet(ref(db, `profiles/${uid}`), { name: displayName, bio: displayBio, avatar: displayAvatar || '' });  
      } else {  
        // if DB profile exists, use it to populate local  
        const p = snap.val();  
        if (p.name) { 
          displayName = p.name; 
          localStorage.setItem('gc_name', displayName); 
          nameField.value = displayName; 
        }  
        if (p.bio)  { 
          displayBio = p.bio; 
          localStorage.setItem('gc_bio', displayBio); 
          bioField.value = displayBio; 
        }  
        if (p.avatar){ 
          displayAvatar = p.avatar; 
          localStorage.setItem('gc_avatar', displayAvatar); 
        }  
      }  
    } catch(err){ 
      console.warn('init profile read failed', err); 
    }  
    refreshProfileUI();  
  })();  
  </script>
</body>
  </html>
